#+TITLE: Documentation
* Intro
  #+BEGIN_QUOTE
  Centralizamos los comentarios sobre las implementaciones en los Makefiles,
  para separar la explicación de la implementación en si
  #+END_QUOTE
* GIT - Branch Upstream
** Escenario
  #+BEGIN_QUOTE
  Supongamos que creamos un repositorio en github (éste es se considera un repositorio remoto),
  entonces no tendría sentido ejecutar las siguientes lineas de comando
  1) ~git fetch origin && git branch --set-upstream-to=origin/master~
  2) ~git pull origin master~
  #+END_QUOTE

  #+BEGIN_QUOTE
  NO tiene sentido ejecutar ~git fetch origin && git branch --set-upstream-to=origin/master~
  1) porque aún NO existe una rama en el repositorio remoto (en github.com)
  2) si no tiene una rama en el repositorio remoto, entonces tampoco tiene ningún commit (cambios confirmados subidos)

  Por tanto es necesario ejecutar en la terminal de comandos ~git push --set-upstream~
  #+END_QUOTE

  #+BEGIN_QUOTE
  NO tiene sentido ejecutar ~git pull origin master~
  porque la operación ~pull~ es una combinación de ~git fetch~ seguido de ~git merge~
  #+END_QUOTE
** Referencias
*** Referencias Oficiales
    1. [[https://git-scm.com/book/es/v2/GitHub-Participando-en-Proyectos][Github participando en proyectos (git-scm.com)]]
*** Referencias Extraoficiales
    1. [[https://www.geeksforgeeks.org/how-to-set-upstream-branch-on-git/][20-02-2022, How to set upstream branch on git (geeksforgeeks.org)]]
    2. [[https://mincong.io/2018/05/02/git-upstream-tracking/][15-08-2019, Git upstream tracking (mincong.io)]]
*** Referencias Issues
    1. [[https://stackoverflow.com/questions/37770467/why-do-i-have-to-git-push-set-upstream-origin-branch][Why do I have to git push set upstream origin branch (stackoverflow.com)]]
* Comando rm - GNU Make Vs Bash
** Escenario
   #+BEGIN_QUOTE
   1) estamos en la ruta ~/tmp/proyecto/sources~
   2) queremos borrar todos los archivos y directorios que están en ~..~ es decir en el directorio padre ~/tmp/proyecto/~
   3) pero..! queremos excluir ó ignorar el directorio ~sources~ en el que estamos ubicados
   #+END_QUOTE
** Solución 1 - Comando find de Bash
  #+BEGIN_SRC makefile
    PWD=$(shell pwd)
    CURRENT_DIRECTORY_NAME = $(notdir $(PWD))

    # hay lógica repetida si, pero el objetivo es otro
    FIND_FILES_COMPLEMENT=find -mindepth 1 -maxdepth 1 -type f -not -name
    FIND_DIRECTORIES_COMPLEMENT=find -mindepth 1 -maxdepth 1 -type d -not -name
    FIND_RM= -exec rm -rf {} \;

    clean:
      cd .. \
      && $(FIND_FILES_COMPLEMENT) $(CURRENT_DIRECTORY_NAME) $(FIND_RM) \
      && $(FIND_DIRECTORIES_COMPLEMENT) $(CURRENT_DIRECTORY_NAME) $(FIND_RM)

    create-files-directories:
      cd .. \
      && mkdir carpetita-1 carpetita-2 carpetita-3\
      && touch archivo-1.txt archivo-2.txt archivo-3.txt

    .PHONY: clean create-files-directories
  #+END_SRC
** Solución 2 - Función filter-out de GNU Make
  #+BEGIN_SRC makefile
    PWD=$(shell pwd)
    CURRENT_DIRECTORY_NAME = $(notdir $(PWD))

    # usamos la funciones wildcard y notdir
    # 1. wildcard ../* para obtener los archivos y directorios de la ruta .. (directorio padre)
    # 2. wildcard ../.* para obtener los archivos ocultos de la ruta .. (directorio padre)
    # 3. notdir obtiene de una ruta A/B/C el nombre del directorio C
    PARENT_DIRECTORY_FILES = $(notdir $(wildcard ../*) $(wildcard ../.*))

    # 1. excluimos la ruta . (directorio actual), no queremos borrar la carpeta actual
    # 2. excluimos la ruta .. (directorio padre del directorio padre),
    # si la ruta es A/B/C estariamos borrando A y sólo queremos borrar B
    EXCLUDED_FILES=$(CURRENT_DIRECTORY_NAME) . ..

    # función filter-out de GNU Make
    PARENT_DIRECTORY_FILES_FILTERED = $(filter-out $(EXCLUDED_FILES), $(PARENT_DIRECTORY_FILES))

    clean:
      cd .. \
      && rm -rfv $(PARENT_DIRECTORY_FILES_FILTERED)

    create-files-directories:
      cd .. \
      && mkdir carpetita-1 carpetita-2 carpetita-3\
      && touch archivo-1.txt archivo-2.txt archivo-3.txt

    .PHONY: clean create-files-directories
  #+END_SRC
** Referencias
*** Referencias Issues
    1. [[https://askubuntu.com/questions/804667/remove-all-directories-from-within-a-parent-directory-except-one-and-its-descend][remove all directories from within a parent directory except one and its descend (askubuntu.com)]]
* GNU Make ifeq con comandos bash como expresiones
** Escenario
   #+BEGIN_SRC makefile
     # nos devuelve true ó false
     CHECK_GIT_INITIALIZED=git rev-parse --is-inside-work-tree

     # definimos la expresión que evalúa el ifneq (if not equal)
     # 1. $(shell) para ejecutar los comandos en la shell de bash (ó sh depende como lo configuramos)
     # 2. cd .. accedemos al directorio padre de la ruta relativa
     # 3. $(GIT_INITIALIZED) expandimos la macro que contiene el comando de git
     # 4. 2>/dev/null redireccionamos la (stderr) la salida estándar de errores a /dev/null para que no aparezca en la pantalla
     #
     # Notas:
     # 1. los condicionales ifeq y ifneq en GNU Make son de la forma ifeq (a,b) y ifneq(a,b)
     # no valida si el valor de la expresión es booleana, hay que preguntarle si es true ó false
     #
     # 2. $(if condicion) valida su es true/false, pero su objetivo es otro..
     # 2.1 es asignarle un valor a una macro según si se cumple la condición evaluada
     # 2.2 podríamos utilizarlo pero quedaría todo muy compacto y no se entendería
     git-init:
     ifneq ($(shell cd .. && $(GIT_INITIALIZED) 2>/dev/null),true)
       $(info Inicializando repositorio de git..)
       $(AT)cd .. \
       && git init
     endif
   #+END_SRC
** Referencias
*** Referencias Extraoficiales
    1. [[https://gist.github.com/rueycheng/42e355d1480fd7a33ee81c866c7fdf78][GNU Make cheatsheet (gist.github.com/rueycheng)]]
*** Referencias Issues
    1. [[https://stackoverflow.com/questions/2180270/check-if-current-directory-is-a-git-repository][Check if current directory is a git repository (stackoverflow.com)]]
    2. [[https://stackoverflow.com/questions/9008649/gnu-make-conditional-function-if-inside-a-user-defined-function-always-ev][GNU Make conditional function if inside a user defined function always (stackoverflow.com)]]
    3. [[https://unix.stackexchange.com/questions/640177/if-function-in-makefile-seems-to-disregard-conditional-and-executes-unexpectedly][if function in makefile seems to disgregard conditional and executes unexpectedly (unix.stackexchange.com)]]
* Target de Seguimiento - Timestamp entre el target y sus dependencias
** Escenario
   #+BEGIN_QUOTE
   Problemas que presenta la regla ~git-hooks-update~:
   1) Copiamos los archivos cada vez que se instancie el target git-hooks-update (Ej. en la terminal make git-hooks-update),
   2) Copiamos apesar de que NO hayan cambios en la carpeta git-hooks
   #+END_QUOTE

   #+BEGIN_SRC makefile
     COPY=rsync -avz
     GIT_HOOKS = $(wildcard git-hooks/*)

     git-hooks-update:
       chmod u+x git-hooks/* \
       && $(COPY) git-hooks/* ../.git/hooks
   #+END_SRC
** Solución 1 - Target de Seguimiento
   #+BEGIN_QUOTE
   Mejoras al problema anterior:
   1) Si existe diferencias entre el *timestamp del target* y el *timetamp de sus dependencias*,
      - se copian TODOS los archivos de ~git-hooks/~ al directorio padre (operación asociada la función ~foreach~)

   2) Utilizamos lo que se llama un *target de seguimiento* (/un archivo vacío que se llamará git-hooks-update/)
      - para marcar el último momento en el que se produjo un evento
      - lo utilizamos sólo para comparar el timestamp de creación contra el timestamp de las dependencias
      - las dependencias aparecen luego de evaluar y expandirse la macro ~$(GIT_HOOKS)~
   #+END_QUOTE

   #+BEGIN_SRC makefile
     COPY=rsync -avz
     GIT_HOOKS = $(wildcard git-hooks/*)

     .targets/git-hooks-update: $(GIT_HOOKS)
     # 1. creamos el directorio que contiene a éste target (archivo)
       $(MKDIR) $(dir $@) && touch $@
     # 2. copiamos los archivos al directorio padre
       $(foreach hook-file, $^,\
         chmod u+x $(hook-file) && \
         $(COPY) $(hook-file) ../.git/hooks; \
       )
   #+END_SRC
** Otras Soluciones
   #+BEGIN_QUOTE
   Alternativas a la solución anterior:
   1) una *regla EXPLÍCITA* del tipo ~../.git/hooks/pre-push: git-hooks/pre-push~ no me parece viable
   2) una *regla IMPLÍCITA* podría implicar un sobrediseño porque..
      - los ficheros NO tienen extensión
      - agregarle una extensión para luego removerla no tiene mucho sentido
   #+END_QUOTE
** Referencias
