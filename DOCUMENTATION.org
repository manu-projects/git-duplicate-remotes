#+TITLE: Documentation
* Intro
  #+BEGIN_QUOTE
  Centralizamos los comentarios sobre las implementaciones en los Makefiles,
  para separar la explicación de la implementación en si
  #+END_QUOTE
* GIT - Branch Upstream
** Escenario
  #+BEGIN_QUOTE
  Supongamos que creamos un repositorio en github (éste es se considera un repositorio remoto),
  entonces no tendría sentido ejecutar las siguientes lineas de comando
  1) ~git fetch origin && git branch --set-upstream-to=origin/master~
  2) ~git pull origin master~
  #+END_QUOTE

  #+BEGIN_QUOTE
  NO tiene sentido ejecutar ~git fetch origin && git branch --set-upstream-to=origin/master~
  1) porque aún NO existe una rama en el repositorio remoto (en github.com)
  2) si no tiene una rama en el repositorio remoto, entonces tampoco tiene ningún commit (cambios confirmados subidos)

  Por tanto es necesario ejecutar en la terminal de comandos ~git push --set-upstream~
  #+END_QUOTE

  #+BEGIN_QUOTE
  NO tiene sentido ejecutar ~git pull origin master~
  porque la operación ~pull~ es una combinación de ~git fetch~ seguido de ~git merge~
  #+END_QUOTE
** Referencias
*** Referencias Oficiales
    1. [[https://git-scm.com/book/es/v2/GitHub-Participando-en-Proyectos][Github participando en proyectos (git-scm.com)]]
*** Referencias Extraoficiales
    1. [[https://www.geeksforgeeks.org/how-to-set-upstream-branch-on-git/][20-02-2022, How to set upstream branch on git (geeksforgeeks.org)]]
    2. [[https://mincong.io/2018/05/02/git-upstream-tracking/][15-08-2019, Git upstream tracking (mincong.io)]]
*** Referencias Issues
    1. [[https://stackoverflow.com/questions/37770467/why-do-i-have-to-git-push-set-upstream-origin-branch][Why do I have to git push set upstream origin branch (stackoverflow.com)]]
* Comando rm - GNU Make Vs Bash
** Escenario
   #+BEGIN_QUOTE
   1) estamos en la ruta ~/tmp/proyecto/sources~
   2) queremos borrar todos los archivos y directorios que están en ~..~ es decir en el directorio padre ~/tmp/proyecto/~
   3) pero..! queremos excluir ó ignorar el directorio ~sources~ en el que estamos ubicados
   #+END_QUOTE
** Solución 1 - Comando find de Bash
  #+BEGIN_SRC makefile
    PWD=$(shell pwd)
    CURRENT_DIRECTORY_NAME = $(notdir $(PWD))

    # hay lógica repetida si, pero el objetivo es otro
    FIND_FILES_COMPLEMENT=find -mindepth 1 -maxdepth 1 -type f -not -name
    FIND_DIRECTORIES_COMPLEMENT=find -mindepth 1 -maxdepth 1 -type d -not -name
    FIND_RM= -exec rm -rf {} \;

    clean:
      cd .. \
      && $(FIND_FILES_COMPLEMENT) $(CURRENT_DIRECTORY_NAME) $(FIND_RM) \
      && $(FIND_DIRECTORIES_COMPLEMENT) $(CURRENT_DIRECTORY_NAME) $(FIND_RM)

    create-files-directories:
      cd .. \
      && mkdir carpetita-1 carpetita-2 carpetita-3\
      && touch archivo-1.txt archivo-2.txt archivo-3.txt

    .PHONY: clean create-files-directories
  #+END_SRC
** Solución 2 - Función filter-out de GNU Make
  #+BEGIN_SRC makefile
    PWD=$(shell pwd)
    CURRENT_DIRECTORY_NAME = $(notdir $(PWD))

    # usamos la funciones wildcard y notdir
    # 1. wildcard ../* para obtener los archivos y directorios de la ruta .. (directorio padre)
    # 2. wildcard ../.* para obtener los archivos ocultos de la ruta .. (directorio padre)
    # 3. notdir obtiene de una ruta A/B/C el nombre del directorio C
    PARENT_DIRECTORY_FILES = $(notdir $(wildcard ../*) $(wildcard ../.*))

    # 1. excluimos la ruta . (directorio actual), no queremos borrar la carpeta actual
    # 2. excluimos la ruta .. (directorio padre del directorio padre),
    # si la ruta es A/B/C estariamos borrando A y sólo queremos borrar B
    EXCLUDED_FILES=$(CURRENT_DIRECTORY_NAME) . ..

    # función filter-out de GNU Make
    PARENT_DIRECTORY_FILES_FILTERED = $(filter-out $(EXCLUDED_FILES), $(PARENT_DIRECTORY_FILES))

    clean:
      cd .. \
      && rm -rfv $(PARENT_DIRECTORY_FILES_FILTERED)

    create-files-directories:
      cd .. \
      && mkdir carpetita-1 carpetita-2 carpetita-3\
      && touch archivo-1.txt archivo-2.txt archivo-3.txt

    .PHONY: clean create-files-directories
  #+END_SRC
** Referencias
*** Referencias Issues
    1. [[https://askubuntu.com/questions/804667/remove-all-directories-from-within-a-parent-directory-except-one-and-its-descend][remove all directories from within a parent directory except one and its descend (askubuntu.com)]]
* GNU Make ifeq con comandos bash como expresiones
** Escenario
   #+BEGIN_SRC makefile
     # nos devuelve true ó false
     GIT_INITIALIZED=git rev-parse --is-inside-work-tree

     # definimos la expresión que evalúa el ifneq (if not equal)
     # 1. $(shell) para ejecutar los comandos en la shell de bash (ó sh depende como lo configuramos)
     # 2. cd .. accedemos al directorio padre de la ruta relativa
     # 3. $(GIT_INITIALIZED) expandimos la macro que contiene el comando de git
     # 4. 2>/dev/null redireccionamos la (stderr) la salida estándar de errores a /dev/null para que no aparezca en la pantalla
     #
     # Notas:
     # 1. los condicionales ifeq y ifneq en GNU Make son de la forma ifeq (a,b) y ifneq(a,b)
     # no valida si el valor de la expresión es booleana, hay que preguntarle si es true ó false
     #
     # 2. $(if condicion) valida su es true/false, pero su objetivo es otro..
     # 2.1 es asignarle un valor a una macro según si se cumple la condición evaluada
     # 2.2 podríamos utilizarlo pero quedaría todo muy compacto y no se entendería
     git-init:
     ifneq ($(shell cd .. && $(GIT_INITIALIZED) 2>/dev/null),true)
       $(info Inicializando repositorio de git..)
       $(AT)cd .. \
       && git init
     endif
   #+END_SRC
** Referencias
*** Referencias Extraoficiales
    1. [[https://gist.github.com/rueycheng/42e355d1480fd7a33ee81c866c7fdf78][GNU Make cheatsheet (gist.github.com/rueycheng)]]
*** Referencias Issues
    1. [[https://stackoverflow.com/questions/2180270/check-if-current-directory-is-a-git-repository][Check if current directory is a git repository (stackoverflow.com)]]
    2. [[https://stackoverflow.com/questions/9008649/gnu-make-conditional-function-if-inside-a-user-defined-function-always-ev][GNU Make conditional function if inside a user defined function always (stackoverflow.com)]]
    3. [[https://unix.stackexchange.com/questions/640177/if-function-in-makefile-seems-to-disregard-conditional-and-executes-unexpectedly][if function in makefile seems to disgregard conditional and executes unexpectedly (unix.stackexchange.com)]]
* Target de Seguimiento - Timestamp entre el target y sus dependencias
** Escenario
   #+BEGIN_QUOTE
   Problemas que presenta la regla ~git-hooks-update~:
   1) Copiamos los archivos cada vez que se instancie el target git-hooks-update (Ej. en la terminal make git-hooks-update),
   2) Copiamos apesar de que NO hayan cambios en la carpeta git-hooks
   #+END_QUOTE

   #+BEGIN_SRC makefile
     COPY=rsync -avz
     GIT_HOOKS = $(wildcard git-hooks/*)

     git-hooks-update:
       chmod u+x git-hooks/* \
       && $(COPY) git-hooks/* ../.git/hooks
   #+END_SRC
** Solución 1 - Target de Seguimiento
   #+BEGIN_QUOTE
   Mejoras al problema anterior:
   1) Si existe diferencias entre el *timestamp del target* y el *timetamp de sus dependencias*,
      - se copian TODOS los archivos de ~git-hooks/~ al directorio padre (operación asociada la función ~foreach~)

   2) Utilizamos lo que se llama un *target de seguimiento* (/un archivo vacío que se llamará git-hooks-update/)
      - para marcar el último momento en el que se produjo un evento
      - lo utilizamos sólo para comparar el timestamp de creación contra el timestamp de las dependencias
      - las dependencias aparecen luego de evaluar y expandirse la macro ~$(GIT_HOOKS)~
   #+END_QUOTE

   #+BEGIN_SRC makefile
     COPY=rsync -avz
     GIT_HOOKS = $(wildcard git-hooks/*)

     .targets/git-hooks-update: $(GIT_HOOKS)
     # 1. creamos el directorio que contiene a éste target (archivo)
       $(MKDIR) $(dir $@) && touch $@
     # 2. copiamos los archivos al directorio padre
       $(foreach hook-file, $^,\
         chmod u+x $(hook-file) && \
         $(COPY) $(hook-file) ../.git/hooks; \
       )
   #+END_SRC
** Otras Soluciones
   #+BEGIN_QUOTE
   Alternativas a la solución anterior:
   1) una *regla EXPLÍCITA* del tipo ~../.git/hooks/pre-push: git-hooks/pre-push~ no me parece viable
   2) una *regla IMPLÍCITA* podría implicar un sobrediseño porque..
      - los ficheros NO tienen extensión
      - agregarle una extensión para luego removerla no tiene mucho sentido
   #+END_QUOTE
** Referencias
* Comando test de bash
** Escenario
   #+BEGIN_SRC makefile
     DIRECTORIO=alumnos
     ARCHIVO=algebra.txt

     GIT_INITIALIZED=git rev-parse --is-inside-work-tree

     BOX_CONFIRM_CLEAN=whiptail --title "Eliminar archivos actual" --yesno "Está seguro de confirmar la acción?" 0 0

     # - el comando test es de la forma test condicion && ejecutar si condicion es true || ejecutando si condicion es false
     # - utilizamos los paréntesis para agrupar las expresiones (no es necesario, pero se entiende mejor)
     validar-git:
       test $(shell $(GIT_INITIALIZED)) \
       && (echo "GIT está inicializado, wow!" && git status) \
       || (echo "GIT NO está inicializado, ups!" && git init)

     # - si al comando test le pasamos el parámetro -d verifica la existencia de un directorio
     validar-directorio:
       @test -d $(DIRECTORIO) \
       && echo "existe! :)" \
       || echo "no existe.. :(" \

     # - si al comando test le pasamos el parámetro -d verifica la existencia de un archivo
     validar-archivo:
       @test -f $(DIRECTORIO)/$(ARCHIVO) \
       && echo "existe! :)" \
       || echo "no existe.. :(" \

     # Notas:
     # 1. podríamos utilizar el operador pipe | y los comandos test, xargs y tee pero se complica la redirección del output del comando whiptail
     # 2. utilizamos los operadores lógicos AND && y el OR ||
     # 3. en el operador lógico OR devolvemos true para que GNU Make no lance una excepción
     clean:
       $(BOX_CONFIRM_CLEAN) \
       && rm -rvf $(DIRECTORIO) .git \
       || true

     # regla para crear un directorio con el nombre con el valor de la expansión de la macro $(DIRECTORIO)
     $(DIRECTORIO):
       $(info Creando directorio $@..)
       mkdir -p $@

     # Notas sobre el target y las dependencias:
     # - regla para crear un archivo con el nombre con el valor de la expansión de las macros $(DIRECTORIO) y $(ARCHIVO)
     # - el target $(DIRECTORIO)/$(ARCHIVO) tiene como dependencia $(DIRECTORIO) es decir ésta dependencia se debe ejecutar primero,
     # porque depende de ella para la creación del target
     # - luego de crear la dependencia, se ejecutará la orden asociada la regla
     #
     # Notas de las macros especiales y las funciones de GNU Make:
     # - $@ es una macro especial que devuelve el nombre del target es decir.. $(DIRECTORIO)/$(ARCHIVO)
     # - $(dir carpeta-1/archivo.txt) devuelve el nombre del directorio de la ruta
     # - $(notdir carpeta-1/archivo.txt) devuelve el nombre del archivo de la ruta
     $(DIRECTORIO)/$(ARCHIVO): $(DIRECTORIO)
       $(info Accediendo al directorio $(dir $@) para crear el archivo $(notdir $@)..)
       cd $(dir $@) \
       && touch $(notdir $@)

     # Notas:
     # 1. $< es una macro especial que devuelve la primer dependencia de la regla es decir $(DIRECTORIO)/$(ARCHIVO)
     #
     # 2. si hubiera más dependencias
     # 2.1 necesitaríamos del comando de bash tee (porque redirecciona stdin a varios archivos)
     # 2.2 y la macro especial $^ (porque devuelve el nombre de todas las dependencias)
     cargar-datos: $(DIRECTORIO)/$(ARCHIVO)
       echo "Pepito Gimenez, legajo 10200100" >> $<
   #+END_SRC
** Problema sin resolver
   #+BEGIN_SRC makefile
     # intentos fallidos
     clean-1:
       $(if $(shell $(BOX_CONFIRM_CLEAN) | tee >/dev/tty), echo "bien")

     clean-2:
       $(BOX_CONFIRM_CLEAN) \
       | tee >/dev/tty \
       | xargs test && echo "borrando archivos.." || echo "no borro nada"

     clean-3:
       $(BOX_CONFIRM_CLEAN) 3>&1 1>&2 2>&3 \
       | xargs test && echo "borrando archivos.." || echo "no borro nada"
   #+END_SRC
** Referencias
*** Referencias Oficiales
    1. [[https://www.redhat.com/sysadmin/linux-shell-redirection-pipelining][Linux shell redirection pipelining (redhat.com)]]
    2. [[https://tldp.org/LDP/abs/html/io-redirection.html][io redirection (tldp.org)]]
*** Referencias Extraoficiales
    1. [[https://www.thegeekdiary.com/test-command-examples-in-linux/][test command examples in linux (thegeekdiary.com)]]
    2. [[https://www.rozmichelle.com/pipes-forks-dups/][pipes forks dups (rozmichelle.com)]]
    3. [[https://distroid.net/xargs-command-linux/][xargs command linux (distroid.net)]]
    4. [[https://til.codeinthehole.com/posts/how-to-use-xargs-with-printf/][how to use xargs with printf (til.codeinthehole.com)]]
    5. [[https://blog.desdelinux.net/shell-bash-y-scripts-todo-sobre-shell-scripting/][shell bash y scripts todo sobre shell scripting (blog.desdelinux.net)]]
*** Referencias Issues
    1. [[https://unix.stackexchange.com/questions/42728/what-does-31-12-23-do-in-a-script][what does 3>&1 1>&2 2>&3 do in a script (unix.stackexchange.com)]]
